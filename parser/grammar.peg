## Grammar for sound change formal notation
##
## Part of the `alteruphono` library;
## see: https://github.com/tresoldi/alteruphono

## TODO: should move all `recons` to `segment`?

#######################

## TODO: add support to segmentation boundary ("significant") whitespace
##       with plus signs or parentheses
## TODO: add syllable breaks
## TODO: Consider allowing single-line comments in future versions.
##       with @@eol_comments :: /##([^\n]*?)$/

## Define the grammar for parsing sound changes
@@grammar::SOUND_CHANGE

## The grammar `start` is defined as a "sound change rule" including
## the three basic elements: an `ante` sequence (mandatory), a `post`
## sequence (mandatory), and a `context` sequence (optional). `ante` and
## `post` are separated by `arrow` terminals, which are not captured;
## `post` and `context` are separated by `slash` terminals, which are not
## captured as well. Note that we match the end of string `$` to guarantee
## that no extra material is included in the string (such as comments).
start =
    | ante:sequence arrow post:sequence slash context:sequence $
    | ante:sequence arrow post:sequence $
    ;

## Collect a sequence of `segment`s; the grammar syntax here (with the
## override from the `@:` operator) guarantees that `choice`s are returned
## as list, while individual `segment`s are parsed "as is" in the AST.
## While a formally more elegant approach would be to have even single
## segments as lists, with the code logic in charge of abstracting it,
## this decision makes the exploration much easier and intuitive for
## people who are not accustomed with PEG grammars, and it also provides for
## easier and faster code when applying rules (as there are less queries).
## Note that `focus` is not listed among `segments`, as it cannot be
## repeated or used in an alternative by our definition.s
sequence = { sequence_element }+ ;
sequence_element =
    | "|".{ @:segment }+
    | focus:focus
    ;

## Define segments as all basic units of sound or position (including
## empty ones) that can be part of a `choice`
## TODO: investigate on alternatives with empty, for optionality
segment =
    | backref:backref
    | sound_class:sound_class
    | boundary:boundary
    | empty:empty
    | ipa:ipa
    ;

## Define feature keys, features (which include keys and values), and feature
## descriptions (i.e., multiple features).
## As features can change across experiments, including due to named tiers,
## there is no point in listing the features; we accept any valid identifier
## as a key, delegating validation to code. Identifiers are composed of
## lowercase letters, digits, underscores, and dashes, with the first
## character a letter. In features, values can either precede and be an
## operator, or follow and be a string value. Features composed only
## of feature keys are accepts, with an implied positive value.
## Feature descriptions are composed of multiple features enclosed by
## square brackets and separated by commas.
## Please note that, unlike the somewhat analogous case of segment alternatives
## (`choice`), here the grammar will make 竜 TatSu capture this as
## a list also in cases of a single feature. This is intentional.
## TODO: allow values besides "true" and "false"
feature_key = /[a-z][a-z0-9_-]+/ ;
feature =
    | value:(r"+"|r"-"|r"!") key:feature_key
    | key:feature_key "=" value:(r"true"|r"false")
    | key:feature_key
    ;
feature_desc = [recons:recons] r"[" ",".{ feature_desc+:feature }+ r"]" ;

## Defines a back-reference, an index with an optional modifier and
## reconstruction flag.
backref =
    | [recons:recons] "@" index:/[0-9]+/ modifier:feature_desc
    | [recons:recons] "@" index:/[0-9]+/
    ;

## Sound class labels are identifiers in uppercase letters or digits, with
## the first character obligatorily a letter.
## Sound class references can be optionally marked as reconstructions by
## a preceding asterisk, and optionally carry a feature description
## modifier.
sound_class_label = /[A-Z][A-Z0-9]*/ ;
sound_class =
  | [recons:recons] sound_class:sound_class_label modifier:feature_desc
  | [recons:recons] sound_class:sound_class_label
  ;

## Define additional capture symbols (actually terminals). Notes:
##   - the `arrow` and `slash` symbols are used but not captured
##   - `boundary` includes regex-standard "^" and "$", but these are matched
##     in whatever position
## TODO: add symbols for syllable and morpheme boundary
boundary = r"#"|r"^"|r"$";
focus = r"_";
empty = r":null:"|r"0";

## Define an IPA capture as all the characters which are non reserved;
## validation of the graphemes is carried after parsing, in code, and
## *not* in the grammar.
## TODO: compile list of reserved characters
## TODO: now that IPA is at the end, can we just match dot?
ipa = [recons:recons] grapheme:/[^ @_#^$=>0|*\/\-]+/ ;

## Reconstruction markers
recons = r"*" | r"**" ; 



## Define non-capture terminals.
arrow = r"==>" | r"-->" | r"->" | r"=>" | r">" | r"→" | r"⇒" | r"⇾" | r"»";
slash = r"//" | r"/" ;
